|Active_noise_cancellation
KEY[0] => ~NO_FANOUT~
KEY[1] => ~NO_FANOUT~
KEY[2] => ~NO_FANOUT~
KEY[3] => clockBuffer:clockBufferInstance.areset
KEY[3] => audioPLLClock:audioPLLClockMap.areset
KEY[3] => delayCounter:delayCounterMap.reset
KEY[3] => LEDG[6].DATAIN
CLOCK_50 => clockBuffer:clockBufferInstance.inclk0
AUD_ADCDAT => AdcDacController:AdcDacControllerMap.A_to_D
AUD_DACDAT <= AdcDacController:AdcDacControllerMap.D_to_A
AUD_ADCLRCK <= AdcDacController:AdcDacControllerMap.A_to_D_LorR
AUD_DACLRCK <= AdcDacController:AdcDacControllerMap.D_to_A_LorR
AUD_XCK <= audioPLLClock:audioPLLClockMap.c0
AUD_BCLK <= AdcDacController:AdcDacControllerMap.bitClock
CLOCK_27 => audioPLLClock:audioPLLClockMap.inclk0
SW[0] => AdcDacController:AdcDacControllerMap.out_select[0]
LEDR[0] <= AdcDacController:AdcDacControllerMap.ledr_on[0]
LEDR[1] <= AdcDacController:AdcDacControllerMap.ledr_on[1]
LEDR[2] <= AdcDacController:AdcDacControllerMap.ledr_on[2]
LEDR[3] <= AdcDacController:AdcDacControllerMap.ledr_on[3]
LEDR[4] <= AdcDacController:AdcDacControllerMap.ledr_on[4]
LEDR[5] <= AdcDacController:AdcDacControllerMap.ledr_on[5]
LEDR[6] <= AdcDacController:AdcDacControllerMap.ledr_on[6]
LEDR[7] <= AdcDacController:AdcDacControllerMap.ledr_on[7]
LEDR[8] <= AdcDacController:AdcDacControllerMap.ledr_on[8]
LEDR[9] <= AdcDacController:AdcDacControllerMap.ledr_on[9]
LEDR[10] <= AdcDacController:AdcDacControllerMap.ledr_on[10]
LEDR[11] <= AdcDacController:AdcDacControllerMap.ledr_on[11]
LEDR[12] <= AdcDacController:AdcDacControllerMap.ledr_on[12]
LEDR[13] <= AdcDacController:AdcDacControllerMap.ledr_on[13]
LEDR[14] <= AdcDacController:AdcDacControllerMap.ledr_on[14]
LEDR[15] <= AdcDacController:AdcDacControllerMap.ledr_on[15]
LEDR[16] <= AdcDacController:AdcDacControllerMap.ledr_on[16]
LEDR[17] <= AdcDacController:AdcDacControllerMap.ledr_on[17]
LEDG[0] <= <GND>
LEDG[1] <= <GND>
LEDG[2] <= <GND>
LEDG[3] <= <GND>
LEDG[4] <= <GND>
LEDG[5] <= <GND>
LEDG[6] <= KEY[3].DB_MAX_OUTPUT_PORT_TYPE
LEDG[7] <= <GND>
LEDG[8] <= <GND>
HEX0[0] <= AdcDacController:AdcDacControllerMap.hex1_sig[0]
HEX0[1] <= AdcDacController:AdcDacControllerMap.hex1_sig[1]
HEX0[2] <= AdcDacController:AdcDacControllerMap.hex1_sig[2]
HEX0[3] <= AdcDacController:AdcDacControllerMap.hex1_sig[3]
HEX0[4] <= AdcDacController:AdcDacControllerMap.hex1_sig[4]
HEX0[5] <= AdcDacController:AdcDacControllerMap.hex1_sig[5]
HEX0[6] <= AdcDacController:AdcDacControllerMap.hex1_sig[6]
HEX1[0] <= AdcDacController:AdcDacControllerMap.hex0_sig[0]
HEX1[1] <= AdcDacController:AdcDacControllerMap.hex0_sig[1]
HEX1[2] <= AdcDacController:AdcDacControllerMap.hex0_sig[2]
HEX1[3] <= AdcDacController:AdcDacControllerMap.hex0_sig[3]
HEX1[4] <= AdcDacController:AdcDacControllerMap.hex0_sig[4]
HEX1[5] <= AdcDacController:AdcDacControllerMap.hex0_sig[5]
HEX1[6] <= AdcDacController:AdcDacControllerMap.hex0_sig[6]


|Active_noise_cancellation|clockBuffer:clockBufferInstance
areset => altpll:altpll_component.areset
inclk0 => altpll:altpll_component.inclk[0]
c0 <= altpll:altpll_component.clk[0]


|Active_noise_cancellation|clockBuffer:clockBufferInstance|altpll:altpll_component
inclk[0] => pll.CLK
inclk[1] => ~NO_FANOUT~
fbin => ~NO_FANOUT~
pllena => ~NO_FANOUT~
clkswitch => ~NO_FANOUT~
areset => pll.ARESET
pfdena => ~NO_FANOUT~
clkena[0] => ~NO_FANOUT~
clkena[1] => ~NO_FANOUT~
clkena[2] => ~NO_FANOUT~
clkena[3] => ~NO_FANOUT~
clkena[4] => ~NO_FANOUT~
clkena[5] => ~NO_FANOUT~
extclkena[0] => ~NO_FANOUT~
extclkena[1] => ~NO_FANOUT~
extclkena[2] => ~NO_FANOUT~
extclkena[3] => ~NO_FANOUT~
scanclk => ~NO_FANOUT~
scanclkena => ~NO_FANOUT~
scanaclr => ~NO_FANOUT~
scanread => ~NO_FANOUT~
scanwrite => ~NO_FANOUT~
scandata => ~NO_FANOUT~
phasecounterselect[0] => ~NO_FANOUT~
phasecounterselect[1] => ~NO_FANOUT~
phasecounterselect[2] => ~NO_FANOUT~
phasecounterselect[3] => ~NO_FANOUT~
phaseupdown => ~NO_FANOUT~
phasestep => ~NO_FANOUT~
configupdate => ~NO_FANOUT~
fbmimicbidir <> <GND>
clk[0] <= clk[0].DB_MAX_OUTPUT_PORT_TYPE
clk[1] <= <GND>
clk[2] <= <GND>
clk[3] <= <GND>
clk[4] <= <GND>
clk[5] <= <GND>
extclk[0] <= <GND>
extclk[1] <= <GND>
extclk[2] <= <GND>
extclk[3] <= <GND>
clkbad[0] <= <GND>
clkbad[1] <= <GND>
enable1 <= <GND>
enable0 <= <GND>
activeclock <= <GND>
clkloss <= <GND>
locked <= <GND>
scandataout <= <GND>
scandone <= <GND>
sclkout0 <= <GND>
sclkout1 <= sclkout1.DB_MAX_OUTPUT_PORT_TYPE
phasedone <= <GND>
vcooverrange <= <GND>
vcounderrange <= <GND>
fbout <= <GND>
fref <= <GND>
icdrclk <= <GND>


|Active_noise_cancellation|audioPLLClock:audioPLLClockMap
areset => altpll:altpll_component.areset
inclk0 => altpll:altpll_component.inclk[0]
c0 <= altpll:altpll_component.clk[0]


|Active_noise_cancellation|audioPLLClock:audioPLLClockMap|altpll:altpll_component
inclk[0] => pll.CLK
inclk[1] => ~NO_FANOUT~
fbin => ~NO_FANOUT~
pllena => ~NO_FANOUT~
clkswitch => ~NO_FANOUT~
areset => pll.ARESET
pfdena => ~NO_FANOUT~
clkena[0] => ~NO_FANOUT~
clkena[1] => ~NO_FANOUT~
clkena[2] => ~NO_FANOUT~
clkena[3] => ~NO_FANOUT~
clkena[4] => ~NO_FANOUT~
clkena[5] => ~NO_FANOUT~
extclkena[0] => ~NO_FANOUT~
extclkena[1] => ~NO_FANOUT~
extclkena[2] => ~NO_FANOUT~
extclkena[3] => ~NO_FANOUT~
scanclk => ~NO_FANOUT~
scanclkena => ~NO_FANOUT~
scanaclr => ~NO_FANOUT~
scanread => ~NO_FANOUT~
scanwrite => ~NO_FANOUT~
scandata => ~NO_FANOUT~
phasecounterselect[0] => ~NO_FANOUT~
phasecounterselect[1] => ~NO_FANOUT~
phasecounterselect[2] => ~NO_FANOUT~
phasecounterselect[3] => ~NO_FANOUT~
phaseupdown => ~NO_FANOUT~
phasestep => ~NO_FANOUT~
configupdate => ~NO_FANOUT~
fbmimicbidir <> <GND>
clk[0] <= clk[0].DB_MAX_OUTPUT_PORT_TYPE
clk[1] <= <GND>
clk[2] <= <GND>
clk[3] <= <GND>
clk[4] <= <GND>
clk[5] <= <GND>
extclk[0] <= <GND>
extclk[1] <= <GND>
extclk[2] <= <GND>
extclk[3] <= <GND>
clkbad[0] <= <GND>
clkbad[1] <= <GND>
enable1 <= <GND>
enable0 <= <GND>
activeclock <= <GND>
clkloss <= <GND>
locked <= <GND>
scandataout <= <GND>
scandone <= <GND>
sclkout0 <= <GND>
sclkout1 <= sclkout1.DB_MAX_OUTPUT_PORT_TYPE
phasedone <= <GND>
vcooverrange <= <GND>
vcounderrange <= <GND>
fbout <= <GND>
fref <= <GND>
icdrclk <= <GND>


|Active_noise_cancellation|delayCounter:delayCounterMap
clock => output.CLK
clock => count[0].CLK
clock => count[1].CLK
clock => count[2].CLK
clock => count[3].CLK
clock => count[4].CLK
clock => count[5].CLK
clock => count[6].CLK
clock => count[7].CLK
clock => count[8].CLK
clock => count[9].CLK
clock => count[10].CLK
clock => count[11].CLK
clock => count[12].CLK
clock => count[13].CLK
clock => count[14].CLK
clock => count[15].CLK
clock => count[16].CLK
clock => count[17].CLK
clock => count[18].CLK
clock => count[19].CLK
clock => count[20].CLK
clock => count[21].CLK
clock => count[22].CLK
clock => count[23].CLK
clock => count[24].CLK
reset => output.ACLR
reset => count[0].ACLR
reset => count[1].ACLR
reset => count[2].ACLR
reset => count[3].ACLR
reset => count[4].ACLR
reset => count[5].ACLR
reset => count[6].ACLR
reset => count[7].ACLR
reset => count[8].ACLR
reset => count[9].ACLR
reset => count[10].ACLR
reset => count[11].ACLR
reset => count[12].ACLR
reset => count[13].ACLR
reset => count[14].ACLR
reset => count[15].ACLR
reset => count[16].ACLR
reset => count[17].ACLR
reset => count[18].ACLR
reset => count[19].ACLR
reset => count[20].ACLR
reset => count[21].ACLR
reset => count[22].ACLR
reset => count[23].ACLR
reset => count[24].ACLR
resetAdc <= output.DB_MAX_OUTPUT_PORT_TYPE


|Active_noise_cancellation|AdcDacController:AdcDacControllerMap
A_to_D => D_to_A.DATAB
A_to_D => D_to_A.DATAA
A_to_D_LorR <= LRchannelCounter:LRchannelCounterMap.LRchannel
D_to_A <= D_to_A.DB_MAX_OUTPUT_PORT_TYPE
D_to_A_LorR <= LRchannelCounter:LRchannelCounterMap.LRchannel
bitClock <= bclk_counter:bclk_counterMap.bclk
reset_n => bclk_counter:bclk_counterMap.reset
reset_n => LRchannelCounter:LRchannelCounterMap.reset
clock18MHz_in => bclk_counter:bclk_counterMap.mclk
out_select[0] => D_to_A.OUTPUTSELECT
out_select[0] => hex0_sig[5].DATAIN
out_select[0] => hex0_sig[4].DATAIN
out_select[0] => hex0_sig[3].DATAIN
out_select[0] => hex0_sig[2].DATAIN
out_select[0] => hex0_sig[1].DATAIN
out_select[0] => hex0_sig[0].DATAIN
out_select[0] => hex1_sig[2].DATAIN
out_select[0] => hex1_sig[4].DATAIN
out_select[0] => hex1_sig[6].DATAIN
out_select[0] => ledr_on[0].DATAIN
out_select[0] => ledr_on[1].DATAIN
out_select[0] => ledr_on[2].DATAIN
out_select[0] => ledr_on[3].DATAIN
out_select[0] => ledr_on[4].DATAIN
out_select[0] => ledr_on[5].DATAIN
out_select[0] => ledr_on[6].DATAIN
out_select[0] => ledr_on[7].DATAIN
out_select[0] => ledr_on[8].DATAIN
out_select[0] => ledr_on[9].DATAIN
out_select[0] => ledr_on[10].DATAIN
out_select[0] => ledr_on[11].DATAIN
out_select[0] => ledr_on[12].DATAIN
out_select[0] => ledr_on[13].DATAIN
out_select[0] => ledr_on[14].DATAIN
out_select[0] => ledr_on[15].DATAIN
out_select[0] => ledr_on[16].DATAIN
out_select[0] => ledr_on[17].DATAIN
ledr_on[0] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[1] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[2] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[3] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[4] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[5] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[6] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[7] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[8] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[9] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[10] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[11] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[12] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[13] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[14] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[15] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[16] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
ledr_on[17] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex1_sig[0] <= <VCC>
hex1_sig[1] <= <VCC>
hex1_sig[2] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex1_sig[3] <= <VCC>
hex1_sig[4] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex1_sig[5] <= <VCC>
hex1_sig[6] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex0_sig[0] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex0_sig[1] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex0_sig[2] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex0_sig[3] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex0_sig[4] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex0_sig[5] <= out_select[0].DB_MAX_OUTPUT_PORT_TYPE
hex0_sig[6] <= <VCC>


|Active_noise_cancellation|AdcDacController:AdcDacControllerMap|bclk_counter:bclk_counterMap
reset => count[0].ACLR
reset => count[1].ACLR
reset => count[2].ACLR
reset => output.ENA
mclk => output.CLK
mclk => count[0].CLK
mclk => count[1].CLK
mclk => count[2].CLK
bclk <= output.DB_MAX_OUTPUT_PORT_TYPE


|Active_noise_cancellation|AdcDacController:AdcDacControllerMap|LRchannelCounter:LRchannelCounterMap
reset => count[0].ACLR
reset => count[1].ACLR
reset => count[2].ACLR
reset => count[3].ACLR
reset => output.PRESET
bclk => count[0].CLK
bclk => count[1].CLK
bclk => count[2].CLK
bclk => count[3].CLK
bclk => output.CLK
LRchannel <= output.DB_MAX_OUTPUT_PORT_TYPE


